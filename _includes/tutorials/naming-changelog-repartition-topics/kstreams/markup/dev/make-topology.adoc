////
In this file you describe the Kafka streams topology, and should cover the main points of the tutorial.
The text assumes a method buildTopology exists and constructs the Kafka Streams application.  Feel free to modify the text below to suit your needs.
////

The point of this tutorial is to discuss the importance of and how to name state stores (hence the resulting changelog topics) and repartition topics.  In addition to having a more clear topology description when executing `Topology.describe()`, you can make your Kafka Streams application more robust to topology changes.  Instead of discussing this in text, let's go over some code to drive the point home.

First look at a snippet of the Kafka Streams application in this tutorial:
+++++
<pre class="snippet"><code class="java">
  KStream&lt;Long, Example&gt; exampleStream = builder.stream(inputTopic, Consumed.with(longSerde, exampleSerde))
                                                  .selectKey((k, v) -> Long.parseLong(v.getName().substring(0, 1)));

  KStream&lt;Long, Long&gt; exampleCountStream = exampleStream.groupByKey().count().toStream();

  ......

</code></pre>
+++++


In the `exampleStream` there is a `selectKey()` operation, changing the key of the incoming stream.  As a result when creating the `exampleCountStream`, the `groupByKey()` operation forces a repartition.  Additionally, `count()` is an aggregation so Kafka Streams creates state store for the count and a changelog topic for fault tolerance of the state store.  When using the DSL, Kafka Streams generates the names for each processor, state store, and any required internal topics.  In this case of the `exampleCountStream` in addition to naming the processors the follwing will have generated names:

* state store - `KSTREAM-AGGREGATE-STATE-STORE-0000000002`
* changelog topic - `KSTREAM-AGGREGATE-STATE-STORE-0000000002-changelog`
* repartition topic - `KSTREAM-AGGREGATE-STATE-STORE-0000000002-repartition`

You'll notice the number suffix `0000000002`.  Kafka Streams uses a number incrementor to name each component.  So far this is very straighforward information.  But when you consider that changelog and repartition topics are stateful, there are some implications to consider when updating the topology.  Let's add a `filter()` processor



With the discussion behind us, go ahead and create the following file at `src/main/java/io/confluent/developer/NamingChangelogAndRepartitionTopics.java`.

+++++
<pre class="snippet"><code class="java">{% include_raw tutorials/naming-changelog-repartition-topics/kstreams/code/src/main/java/io/confluent/developer/NamingChangelogAndRepartitionTopics.java %}</code></pre>
+++++
